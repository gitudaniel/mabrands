##Notes on the actual build
-------------------------------------------------------------------------------
For the actual build, I started off by building a simple backend API.
The django-rest-framework has a great guide for this.
This is what I followed.

I started off by writing the models that would be used by the API.
I gave my model the name Info.
The data collector I gave the name owner.
This is inherited from the user model.
I was working with the notion that only a logged in user can POST data.
Therefore once the data is posted it gets the username of the user and adds it to the data to maintain data integrity.
I also added the attribute on_delete=models.PROTECT.
This makes sure that if a user deletes their account, the data they entered still retains the owner details. This gives credibility to the data even if a data collector leaves the company or deletes the account.

For the location I split it into longitude and latitude.
Initially I wanted the longitude and latitude to have the PointField attribute.
This however, gave me the error PointField required gdal.
GDAL is the Geospatial Data Abstraction Library. It makes it easier for django to deal with map co-ordinates. (Reference: https://docs.djangoproject.com/en/1.11/ref/contrib/gis/gdal/)
I determined there was not enough time to go and fix this error so I went for the next best thing, a DecimalField and I restricted the decimals to 6 since coordinates have 6 decimal places.

The favorite drink I gave the attribute CharField.

For the date, I gave the attribute auto_add_now=True so that the date is automatically generated by django once the form is posted. This helps retain data integrity since we do not have to depend on the data collector to add this.
I also set the timezone to 'Africa/Nairobi' since the default timezone is 'UTC'. Setting 'Africa/Nairobi' is equivalent to setting 'UTC+3' which is Nairobi's timezone.

In the serializer, I implemented a modelserializer.
In the class Meta however I excluded the longitude and latitude fields.
This is because by default django-rest-framework(DRF from here on) will parse any integers to strings. To prevent this, the coerce_to_string needs to be set to False.
I saw this as important since someone interacting with the API might want to input the coordinates into a map. They should be able to get the longitude and latitude and use them as is in a map.

To  make sure that only the owner has POST and PUT permissions, I created the file permissions.py and subclassed the BasePermission class in DRF and gave all users read permissions but only the object owner write permissions.

For the url structure, since this is a backend API, anyone visiting the site is interested in either utilizing or viewing the API. I set the page / to display all data in the backend API and users can proceed from there.

To obtain the JSONWebToken(JWT here onwards) a user needs to navigate to the /api-auth/ page and enter their credentials. This only applies to existing users. Unfortunately I was unable to implement a usecase where a user can create an account to use the API.

Once I had this a deployment was made to mabrands.com

For the Admin console, I decided I would build at least a registration page and display all the data in the backend API.
For modulatity, I decided to make it a separate app and created a separate branch for it while in development.
This would make sure that if anything went wrong while in development, all the features I had built would generally remain intact

Much time was spent thinking that I had to get the data from my database to display it.
I finally realized that I could use my own API to display the data but a lot of time had passed.

I did implement a basic registration using django-registration-redux thought a lot of work still has to be done. This can be found under ^/accounts/register
The login still needs some tweaking to be able to work.

I was able to display all the data in the API on the ^/brands/ urlusing requests. This works locally but not in production. I get a server error 500 while trying to access any of the Admin console features. Further sleuthing will be done to find the error and fix it.

To make all users superusers, I would need to subclass the django-registration-redux RegistrationView and set is_superuser=True
To give the superusers POST and PUT rights I would need to add in write permissions in permissions.py for users with the is_superuser attribute.

Even though I was unable to implement tests, from a preliminary assessment, here is what I would need to test for:
  That all the urls resolve to their correct views
  That a user requires a JSONWebToken to be able to login
  That a POST or PUT can only be made by the owner of the information or a superuser
  That a POST or PUT request modifies the database with the correct information.
  That a GET request displays all information in the backend API
  That the data contains the fields owner, interviewee, longitude, latitude, favorite and created

-------------------------------------------------------------------------------
##Thoughts
For this exercise, given that time was a constraint, I realized that I could not reasonably implement everything.
I therefore decided that the API was a more integral part and more focus should be placed there.
This is because everything else will depend on the existence of the API.

Even though I did implement an API, I would still need to go back and review to gain a better understanding.
For this task I was only skimming throuht taking what I thought would work.
This exercise has given me the base I need to start from since as I go back, I will be able to visualize what I am doing.
I do however like this model of learning. Jump into the deep end to learn on the fly and get a grasp of what's going on and then step back to understand the nitty gritties of it all.

I have also noticed that even though I have an idea of what I need to do, I still need to google to get specifics and this does eat into my development time.
